<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claude Code Swarm Dashboard</title>
<style>
  :root {
    --bg: #0f1117;
    --surface: #1a1d27;
    --border: #2a2d3a;
    --text: #e1e4ed;
    --text-dim: #8b8fa3;
    --accent: #6c5ce7;
    --green: #00b894;
    --yellow: #fdcb6e;
    --red: #e17055;
    --blue: #74b9ff;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    background: var(--bg);
    color: var(--text);
    padding: 20px;
    font-size: 14px;
  }
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 20px;
  }
  header h1 { font-size: 18px; font-weight: 600; }
  .header-meta { color: var(--text-dim); font-size: 12px; }
  .metrics-bar {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
  }
  .metric-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 14px;
    text-align: center;
  }
  .metric-card .value {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 4px;
  }
  .metric-card .label { font-size: 11px; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .metric-green .value { color: var(--green); }
  .metric-yellow .value { color: var(--yellow); }
  .metric-red .value { color: var(--red); }
  .metric-blue .value { color: var(--blue); }
  .metric-accent .value { color: var(--accent); }

  section { margin-bottom: 24px; }
  section h2 {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-dim);
    margin-bottom: 12px;
  }

  .agent-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 10px;
  }
  .agent-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .agent-name { font-weight: 600; }
  .status-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
  }
  .status-running { background: rgba(108, 92, 231, 0.2); color: var(--accent); }
  .status-completed { background: rgba(0, 184, 148, 0.2); color: var(--green); }
  .status-failed { background: rgba(225, 112, 85, 0.2); color: var(--red); }
  .status-timeout { background: rgba(253, 203, 110, 0.2); color: var(--yellow); }
  .status-pending { background: rgba(139, 143, 163, 0.2); color: var(--text-dim); }
  .status-pr_created { background: rgba(116, 185, 255, 0.2); color: var(--blue); }
  .status-in_progress { background: rgba(108, 92, 231, 0.2); color: var(--accent); }
  .status-resolved { background: rgba(0, 184, 148, 0.2); color: var(--green); }
  .status-needs_human { background: rgba(225, 112, 85, 0.2); color: var(--red); }
  .status-rate_limited { background: rgba(253, 203, 110, 0.3); color: var(--yellow); }
  .status-resumed { background: rgba(116, 185, 255, 0.2); color: var(--blue); }

  .agent-details {
    font-size: 12px;
    color: var(--text-dim);
    margin-bottom: 8px;
  }
  .agent-details span { margin-right: 16px; }

  .log-stream {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px;
    max-height: 500px;
    overflow-y: auto;
    font-size: 11px;
    line-height: 1.6;
  }
  .log-stream .log-line { color: var(--text-dim); word-break: break-word; padding: 2px 0; }
  .log-stream .log-line .log-time { color: var(--text-dim); opacity: 0.6; margin-right: 8px; }
  .log-stream .log-line .log-type { margin-right: 8px; font-weight: 600; }
  .log-stream .log-line .log-type.t-assistant { color: var(--accent); }
  .log-stream .log-line .log-type.t-tool_use { color: var(--yellow); }
  .log-stream .log-line .log-type.t-tool_result { color: var(--text-dim); }
  .log-stream .log-line .log-type.t-result { color: var(--green); }
  .log-stream .log-line .log-type.t-error { color: var(--red); }
  .log-stream .log-line .log-type.t-system { color: var(--blue); }

  .issue-table, .pr-table {
    width: 100%;
    border-collapse: collapse;
  }
  .issue-table th, .pr-table th {
    text-align: left;
    font-size: 11px;
    color: var(--text-dim);
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
  }
  .issue-table td, .pr-table td {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
    font-size: 13px;
  }
  .empty-state {
    text-align: center;
    padding: 24px;
    color: var(--text-dim);
    font-style: italic;
  }
  .pr-threads-row td {
    padding: 0 12px 12px 12px;
    border-bottom: 1px solid var(--border);
  }
  .pr-threads {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .pr-thread {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 8px 10px;
    font-size: 12px;
  }
  .pr-thread-file {
    font-size: 11px;
    color: var(--blue);
    margin-bottom: 4px;
  }
  .pr-thread-comment {
    color: var(--text-dim);
    line-height: 1.5;
    margin-top: 2px;
  }
  .pr-thread-comment .thread-author {
    color: var(--text);
    font-weight: 600;
    margin-right: 6px;
  }
  .log-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    margin-top: 4px;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 11px;
    user-select: none;
    border-radius: 4px;
    transition: background 0.15s;
  }
  .log-toggle:hover { background: rgba(255,255,255,0.04); color: var(--text); }
  .log-toggle .chevron {
    display: inline-block;
    transition: transform 0.2s;
    font-size: 9px;
  }
  .log-toggle .chevron.open { transform: rotate(90deg); }

  .pr-toggle {
    cursor: pointer;
    color: var(--accent);
    font-size: 11px;
    user-select: none;
  }
  .pr-toggle:hover { text-decoration: underline; }
</style>
</head>
<body>
<header>
  <h1>Claude Code Swarm</h1>
  <div class="header-meta">
    <span id="agent-count">—</span> |
    <span id="last-updated">—</span>
  </div>
</header>

<div class="metrics-bar">
  <div class="metric-card metric-green"><div class="value" id="m-resolved">—</div><div class="label">Resolved</div></div>
  <div class="metric-card metric-yellow"><div class="value" id="m-pending">—</div><div class="label">In Queue</div></div>
  <div class="metric-card metric-accent"><div class="value" id="m-in-progress">—</div><div class="label">In Progress</div></div>
  <div class="metric-card metric-blue"><div class="value" id="m-pr-created">—</div><div class="label">PRs Open</div></div>
  <div class="metric-card metric-red"><div class="value" id="m-needs-human">—</div><div class="label">Needs Human</div></div>
  <div class="metric-card metric-yellow"><div class="value" id="m-rate-limited">—</div><div class="label">Rate Limited</div></div>
  <div class="metric-card"><div class="value" id="m-avg-turns">—</div><div class="label">Avg Turns</div></div>
</div>

<section>
  <h2>Active Agents</h2>
  <div id="agents-list"><div class="empty-state">No agents running</div></div>
</section>

<section>
  <h2>Issue Queue</h2>
  <div id="issues-list"><div class="empty-state">No issues tracked</div></div>
</section>

<section>
  <h2>PR Tracker</h2>
  <div id="prs-list"><div class="empty-state">No PRs tracked</div></div>
</section>

<script>
const API = '';
const POLL_MS = 3000;

function statusBadge(status) {
  return `<span class="status-badge status-${status}">${status.replace('_', ' ')}</span>`;
}

function timeAgo(ts) {
  if (!ts) return '—';
  const d = new Date(ts + 'Z');
  const diff = Math.floor((Date.now() - d.getTime()) / 1000);
  if (diff < 60) return diff + 's ago';
  if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
  return Math.floor(diff / 3600) + 'h ago';
}

function formatLogTime(ts) {
  if (!ts) return '';
  const d = new Date(ts + 'Z');
  return d.toLocaleTimeString('en-US', { hour12: false });
}

async function fetchJSON(url) {
  try {
    const r = await fetch(url);
    return await r.json();
  } catch(e) { return null; }
}

async function updateMetrics() {
  const m = await fetchJSON(API + '/api/metrics');
  if (!m) return;
  document.getElementById('m-resolved').textContent = m.resolved;
  document.getElementById('m-pending').textContent = m.pending;
  document.getElementById('m-in-progress').textContent = m.in_progress;
  document.getElementById('m-pr-created').textContent = m.pr_created;
  document.getElementById('m-needs-human').textContent = m.needs_human;
  document.getElementById('m-rate-limited').textContent = m.rate_limited || 0;
  document.getElementById('m-avg-turns').textContent = m.avg_turns;
  document.getElementById('agent-count').textContent = `${m.active_agents} agents active`;
  document.getElementById('last-updated').textContent = new Date().toLocaleTimeString();
}

// Track which agent IDs are currently rendered so we only rebuild when the list changes
let currentAgentIds = [];
const agentLogState = {};

// Track which finished agents have their logs manually expanded (persists across polls)
const expandedAgentLogs = new Set();

function isAgentFinished(status) {
  return !['running', 'rate_limited'].includes(status);
}

function toggleAgentLogs(agentId) {
  const logsEl = document.getElementById(`logs-${agentId}`);
  const toggleEl = document.getElementById(`log-toggle-${agentId}`);
  if (!logsEl) return;
  if (expandedAgentLogs.has(agentId)) {
    expandedAgentLogs.delete(agentId);
    logsEl.setAttribute('hidden', '');
    if (toggleEl) {
      toggleEl.querySelector('.chevron').classList.remove('open');
      toggleEl.querySelector('.toggle-label').textContent = 'Show Logs';
    }
  } else {
    expandedAgentLogs.add(agentId);
    logsEl.removeAttribute('hidden');
    if (toggleEl) {
      toggleEl.querySelector('.chevron').classList.add('open');
      toggleEl.querySelector('.toggle-label').textContent = 'Hide Logs';
    }
  }
}

async function updateAgents() {
  const data = await fetchJSON(API + '/api/agents');
  if (!data) return;
  const el = document.getElementById('agents-list');
  const agents = data.agents || [];
  if (agents.length === 0) {
    el.innerHTML = '<div class="empty-state">No agents tracked yet</div>';
    currentAgentIds = [];
    return;
  }
  // Show running and rate-limited first, then recent completed
  const running = agents.filter(a => a.status === 'running');
  const rateLimited = agents.filter(a => a.status === 'rate_limited');
  const recent = agents.filter(a => !['running', 'rate_limited'].includes(a.status)).slice(0, 5);
  const display = [...running, ...rateLimited, ...recent];
  const newIds = display.map(a => a.agent_id);

  // Check if the list of agents changed — only rebuild DOM if it did
  const listChanged = newIds.length !== currentAgentIds.length || newIds.some((id, i) => id !== currentAgentIds[i]);

  if (listChanged) {
    // Reset log state for agents that are being rebuilt
    for (const id of currentAgentIds) {
      delete agentLogState[id];
    }
    currentAgentIds = newIds;

    el.innerHTML = display.map(a => {
      const finished = isAgentFinished(a.status);
      const logsVisible = !finished || expandedAgentLogs.has(a.agent_id);
      return `
      <div class="agent-card" id="card-${a.agent_id}">
        <div class="agent-header">
          <span class="agent-name">${a.agent_id}</span>
          ${statusBadge(a.status)}
        </div>
        <div class="agent-details">
          <span>Issue: #${a.issue_number}</span>
          ${a.pr_number ? `<span>PR: #${a.pr_number}</span>` : ''}
          <span>Type: ${a.agent_type}</span>
          <span>Turns: ${a.turns_used || 0}</span>
          <span>Branch: ${a.branch_name || '—'}</span>
          <span>Started: ${timeAgo(a.started_at)}</span>
        </div>
        ${finished ? `<div class="log-toggle" id="log-toggle-${a.agent_id}" onclick="toggleAgentLogs('${a.agent_id}')"><span class="chevron ${logsVisible ? 'open' : ''}">&#9654;</span><span class="toggle-label">${logsVisible ? 'Hide' : 'Show'} Logs</span></div>` : ''}
        <div class="log-stream" id="logs-${a.agent_id}"${!logsVisible ? ' hidden' : ''}></div>
      </div>`;
    }).join('');
  } else {
    // Update metadata in-place without destroying the log DOM
    for (const a of display) {
      const card = document.getElementById(`card-${a.agent_id}`);
      if (!card) continue;
      const header = card.querySelector('.agent-header');
      if (header) {
        header.innerHTML = `<span class="agent-name">${a.agent_id}</span>${statusBadge(a.status)}`;
      }
      const details = card.querySelector('.agent-details');
      if (details) {
        details.innerHTML = `
          <span>Issue: #${a.issue_number}</span>
          ${a.pr_number ? `<span>PR: #${a.pr_number}</span>` : ''}
          <span>Type: ${a.agent_type}</span>
          <span>Turns: ${a.turns_used || 0}</span>
          <span>Branch: ${a.branch_name || '—'}</span>
          <span>Started: ${timeAgo(a.started_at)}</span>
        `;
      }

      // Handle status transitions: add/remove log toggle as needed
      const finished = isAgentFinished(a.status);
      const existingToggle = document.getElementById(`log-toggle-${a.agent_id}`);
      const logsEl = document.getElementById(`logs-${a.agent_id}`);

      if (finished && !existingToggle) {
        // Agent just finished — insert toggle and collapse logs (unless user expanded)
        const logsVisible = expandedAgentLogs.has(a.agent_id);
        const toggleDiv = document.createElement('div');
        toggleDiv.className = 'log-toggle';
        toggleDiv.id = `log-toggle-${a.agent_id}`;
        toggleDiv.onclick = () => toggleAgentLogs(a.agent_id);
        toggleDiv.innerHTML = `<span class="chevron ${logsVisible ? 'open' : ''}">&#9654;</span><span class="toggle-label">${logsVisible ? 'Hide' : 'Show'} Logs</span>`;
        if (logsEl) {
          card.insertBefore(toggleDiv, logsEl);
          if (!logsVisible) logsEl.setAttribute('hidden', '');
        }
      } else if (!finished && existingToggle) {
        // Agent resumed — remove toggle and show logs
        existingToggle.remove();
        if (logsEl) logsEl.removeAttribute('hidden');
      }
    }
  }

  // Fetch logs for all displayed agents
  for (const a of display) {
    fetchAgentLogs(a.agent_id);
  }
}

async function fetchAgentLogs(agentId) {
  const el = document.getElementById(`logs-${agentId}`);
  if (!el) return;

  // Initialize state for this agent
  if (!agentLogState[agentId]) {
    agentLogState[agentId] = { lastId: 0 };
  }
  const state = agentLogState[agentId];

  const data = await fetchJSON(API + `/api/agents/${agentId}/logs?since=${state.lastId}`);
  if (!data) return;
  const events = data.events || [];

  if (events.length === 0) {
    // Show placeholder only if log area is completely empty
    if (el.children.length === 0) {
      el.innerHTML = '<div class="log-line log-placeholder" style="opacity:0.5">Waiting for events...</div>';
    }
    return;
  }

  // Clear placeholder if present
  const placeholder = el.querySelector('.log-placeholder');
  if (placeholder) placeholder.remove();

  // Check if user is near the bottom before appending (within 50px)
  const wasNearBottom = (el.scrollHeight - el.scrollTop - el.clientHeight) < 50;

  // Append new events incrementally
  for (const e of events) {
    const summary = tryParseEventData(e.event_data, e.event_type);
    if (!summary) continue;
    const line = document.createElement('div');
    line.className = 'log-line';
    line.innerHTML = `<span class="log-time">${formatLogTime(e.timestamp)}</span><span class="log-type t-${e.event_type}">${e.event_type}</span>${escapeHtml(summary)}`;
    el.appendChild(line);
    state.lastId = Math.max(state.lastId, e.id);
  }

  // Only auto-scroll if user was already at the bottom
  if (wasNearBottom) {
    el.scrollTop = el.scrollHeight;
  }
}

function tryParseEventData(raw, eventType) {
  try {
    const d = JSON.parse(raw);

    if (eventType === 'assistant' || d.type === 'assistant') {
      const blocks = d.message?.content || [];
      const parts = [];
      for (const b of blocks) {
        if (b.type === 'text' && b.text) parts.push(b.text);
        else if (b.type === 'tool_use') parts.push(`[calling ${b.name || 'tool'}]`);
        else if (typeof b === 'string') parts.push(b);
      }
      return parts.join(' ') || null;
    }

    if (eventType === 'tool_use' || d.type === 'tool_use') {
      const tool = d.tool || d.name || 'unknown';
      const input = d.input || {};
      if (tool === 'Bash') return `$ ${input.command || ''}`;
      if (tool === 'Read') return `Read ${input.file_path || '?'}`;
      if (tool === 'Edit' || tool === 'Write') return `${tool} ${input.file_path || '?'}`;
      if (tool === 'Grep') return `Grep "${input.pattern || ''}"`;
      if (tool === 'Glob') return `Glob ${input.pattern || ''}`;
      return `${tool}: ${JSON.stringify(input)}`;
    }

    if (eventType === 'tool_result' || d.type === 'tool_result') {
      return null; // skip tool results to reduce noise
    }

    if (eventType === 'result' || d.type === 'result') {
      const r = d.result;
      if (typeof r === 'string') return r;
      if (r && typeof r === 'object') return JSON.stringify(r);
      return 'Agent finished';
    }

    if (eventType === 'error' || d.type === 'error') {
      const err = d.error;
      if (typeof err === 'string') return err;
      if (err && err.message) return err.message;
      return 'Error occurred';
    }

    if (eventType === 'system' || d.type === 'system') {
      if (d.subtype === 'init') return `Session started in ${d.cwd || '?'}`;
      return d.message || d.text || JSON.stringify(d);
    }

    return JSON.stringify(d);
  } catch { return raw || null; }
}

function escapeHtml(s) {
  if (!s) return '';
  const div = document.createElement('div');
  div.textContent = s;
  return div.innerHTML;
}

// Track which PR thread details are expanded
const expandedPRs = new Set();

function togglePRDetails(prNumber) {
  if (expandedPRs.has(prNumber)) {
    expandedPRs.delete(prNumber);
  } else {
    expandedPRs.add(prNumber);
  }
  const row = document.getElementById(`pr-threads-${prNumber}`);
  if (row) row.toggleAttribute('hidden');
}

function formatReviewThreads(threads) {
  if (!threads || threads.length === 0) return '';
  return `<div class="pr-threads">${threads.map(t => {
    const file = t.path || 'unknown';
    const line = t.line ? `:${t.line}` : '';
    const comments = (t.comments || []).map(c =>
      `<div class="pr-thread-comment"><span class="thread-author">${escapeHtml(c.author || 'unknown')}</span>${escapeHtml(c.body || '')}</div>`
    ).join('');
    return `<div class="pr-thread"><div class="pr-thread-file">${escapeHtml(file)}${line}</div>${comments}</div>`;
  }).join('')}</div>`;
}

async function updateIssues() {
  const data = await fetchJSON(API + '/api/issues');
  if (!data) return;
  const el = document.getElementById('issues-list');
  const issues = data.issues || [];
  if (issues.length === 0) {
    el.innerHTML = '<div class="empty-state">No issues tracked yet</div>';
    return;
  }
  el.innerHTML = `<table class="issue-table">
    <tr><th>#</th><th>Title</th><th>Status</th><th>PR</th><th>Attempts</th><th>Updated</th></tr>
    ${issues.map(i => `<tr>
      <td>${i.issue_number}</td>
      <td>${escapeHtml(i.title)}</td>
      <td>${statusBadge(i.status)}</td>
      <td>${i.pr_number ? '#' + i.pr_number : '—'}</td>
      <td>${i.attempts}</td>
      <td>${timeAgo(i.updated_at)}</td>
    </tr>`).join('')}
  </table>`;
}

async function updatePRs() {
  const data = await fetchJSON(API + '/api/prs');
  if (!data) return;
  const el = document.getElementById('prs-list');
  const prs = data.prs || [];
  if (prs.length === 0) {
    el.innerHTML = '<div class="empty-state">No PRs tracked yet</div>';
    return;
  }
  const rows = prs.map(p => {
    const threads = p.review_threads || [];
    const hasThreads = threads.length > 0;
    const isExpanded = expandedPRs.has(p.pr_number);
    return `<tr>
      <td>#${p.pr_number}</td>
      <td>${p.iterations}</td>
      <td>${statusBadge(p.latest_status)}</td>
      <td>${p.total_comments}${hasThreads ? ` <span class="pr-toggle" onclick="togglePRDetails(${p.pr_number})">[${isExpanded ? 'hide' : 'details'}]</span>` : ''}</td>
    </tr>${hasThreads ? `<tr class="pr-threads-row" id="pr-threads-${p.pr_number}"${isExpanded ? '' : ' hidden'}><td colspan="4">${formatReviewThreads(threads)}</td></tr>` : ''}`;
  }).join('');
  el.innerHTML = `<table class="pr-table">
    <tr><th>PR</th><th>Iterations</th><th>Status</th><th>Comments</th></tr>
    ${rows}
  </table>`;
}

async function poll() {
  await Promise.all([updateMetrics(), updateAgents(), updateIssues(), updatePRs()]);
}

poll();
setInterval(poll, POLL_MS);
</script>
</body>
</html>
